# -*- coding: utf-8 -*-
"""app_flask

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pOc4kOVGpVQ5g3bwKgcks24q3V5lKNpk
"""

from flask import Flask, request, jsonify
import openai
import requests
import json
import os

# åˆå§‹åŒ– Flask app
app = Flask(__name__)

# ç’°å¢ƒè®Šæ•¸ï¼ˆå»ºè­°æ”¹ç”¨ Render çš„ç’°å¢ƒè®Šæ•¸è¨­å®šï¼‰
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
NOTION_API_KEY = os.getenv("NOTION_API_KEY")
DB_WORSHIP_HISTORY = os.getenv("DB_WORSHIP_HISTORY")
DB_SONGS = os.getenv("DB_SONGS")

openai.api_key = OPENAI_API_KEY

notion_headers = {
    "Authorization": f"Bearer {NOTION_API_KEY}",
    "Notion-Version": "2022-06-28",
    "Content-Type": "application/json"
}

conversation_history = []

def extract_text(property_item):
    if not property_item:
        return ""
    if "title" in property_item:
        return "".join([t["plain_text"] for t in property_item["title"]])
    if "rich_text" in property_item:
        return "".join([t["plain_text"] for t in property_item["rich_text"]])
    if "multi_select" in property_item:
        return ", ".join([t["name"] for t in property_item["multi_select"]])
    if "people" in property_item:
        return ", ".join([t["name"] for t in property_item["people"]])
    if "date" in property_item and property_item["date"]:
        return property_item["date"].get("start", "")
    return str(property_item)

def fetch_notion_db(database_id):
    url = f"https://api.notion.com/v1/databases/{database_id}/query"
    all_data = []
    next_cursor = None
    while True:
        payload = {"page_size": 100}
        if next_cursor:
            payload["start_cursor"] = next_cursor
        res = requests.post(url, headers=notion_headers, json=payload)
        res.raise_for_status()
        data = res.json()
        all_data.extend(data.get("results", []))
        next_cursor = data.get("next_cursor")
        if not next_cursor:
            break
    return all_data

def build_song_lookup(song_data):
    lookup = {}
    for item in song_data:
        song_id = item["id"]
        props = item["properties"]
        name = extract_text(props.get("æ­Œå"))
        link = extract_text(props.get("é€£çµ"))
        song_type = extract_text(props.get("é¡å‹"))
        lyrics = extract_text(props.get("æ­Œè©"))
        lookup[song_id] = {
            "name": name,
            "type": song_type,
            "link": link,
            "lyrics": lyrics
        }
    return lookup

def ask_gpt(user_question, notion_data, songs_lookup):
    formatted_data = []
    for row in notion_data:
        props = row["properties"]

        def resolve_songs(field_name):
            ids = props.get(field_name, {}).get("relation", [])
            return [
                f"{songs_lookup[s['id']]['name']} ({songs_lookup[s['id']]['type']})\n{songs_lookup[s['id']]['link']}\næ­Œè©ï¼š{songs_lookup[s['id']]['lyrics']}"
                if s["id"] in songs_lookup else s["id"]
                for s in ids
            ]

        item = {
            "ä¸»æ—¥æ—¥æœŸ": extract_text(props.get("ä¸»æ—¥æ—¥æœŸ")),
            "è¬›é“é¡Œç›®": extract_text(props.get("è¬›é“é¡Œç›®")),
            "è¬›å“¡": extract_text(props.get("è¬›å“¡")),
            "ç¶“æ–‡": extract_text(props.get("ç¶“æ–‡")),
            "ä¸»é¡Œ": extract_text(props.get("ä¸»é¡Œ")),
            "å¿«æ­Œ": resolve_songs("å¿«æ­Œï¼ˆè©³æƒ…ï¼‰"),
            "æ…¢æ­Œ": resolve_songs("æ…¢æ­Œï¼ˆè©³æƒ…ï¼‰"),
        }
        formatted_data.append(item)

    prompt = f"""
ä½ æ˜¯ä¸€å€‹æ•¬æ‹œåœ˜è³‡æ–™æŸ¥è©¢åŠ©æ‰‹ï¼Œæœƒæ ¹æ“šç¶“æ–‡ã€ä¸»é¡Œã€è¬›é“å…§å®¹ã€æ­Œè©ï¼Œå¹«å¿™æ¨è–¦è©©æ­Œã€‚

è«‹é‡å°ä½¿ç”¨è€…çš„å•é¡Œï¼Œæ‰¾å‡ºæœ€ç¬¦åˆçš„ä¸»æ—¥ç´€éŒ„æˆ–æ­Œæ›²ã€‚
é™¤äº†æ¢åˆ—è³‡æ–™å¤–ï¼Œè«‹å˜—è©¦èªªæ˜ã€Œç‚ºä»€éº¼é¸é€™é¦–æ­Œã€

ä½¿ç”¨è€…çš„å•é¡Œæ˜¯ï¼šã€Œ{user_question}ã€

é€™æ˜¯ä½ ç›®å‰å¯åƒè€ƒçš„ä¸»æ—¥è³‡æ–™ï¼ˆæœ€å¤šåˆ—å‡º 30 ç­†ï¼‰ï¼š

{json.dumps(formatted_data[:30], ensure_ascii=False, indent=2)}
    """

    messages = [
        {"role": "system", "content": "ä½ æ˜¯æ•¬æ‹œåœ˜æ­·å²è³‡æ–™æŸ¥è©¢åŠ©æ‰‹"},
        *conversation_history,
        {"role": "user", "content": prompt}
    ]

    response = openai.chat.completions.create(
        model="gpt-4o",
        messages=messages,
        temperature=0.3
    )

    conversation_history.append({"role": "user", "content": user_question})
    conversation_history.append({"role": "assistant", "content": response.choices[0].message.content})

    return response.choices[0].message.content

@app.route("/")
def home():
    return "ğŸŸ¢ Worship Assistant is running."

@app.route("/ask", methods=["POST"])
def handle_ask():
    try:
        user_input = request.json.get("question", "")
        if not user_input:
            return jsonify({"error": "Missing 'question' in request"}), 400

        worship_data = fetch_notion_db(DB_WORSHIP_HISTORY)
        song_data = fetch_notion_db(DB_SONGS)
        songs_lookup = build_song_lookup(song_data)

        reply = ask_gpt(user_input, worship_data, songs_lookup)
        return jsonify({"reply": reply})

    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == "__main__":
    app.run(debug=True)